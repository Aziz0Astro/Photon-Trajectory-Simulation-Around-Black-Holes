# -*- coding: utf-8 -*-
"""CubicEquationSolver.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kD6WIjfPkP3_Yh_Ogl7xSA9fbXxHsCdq
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
import warnings
from coloredLine import colored_line_between_pts  # Import custom function for colored line plotting


# Function to solve a cubic equation of the form ax^3 + bx^2 + cx + d = 0
def solve_cubic(a, b, c, d):
    """
    Solves the cubic equation ax^3 + bx^2 + cx + d = 0.

    The function uses Cardano's method for one real root and Viete's trigonometric method
    for three real roots, depending on the discriminant of the depressed cubic.

    Parameters:
        a, b, c, d: Coefficients of the cubic equation.

    Returns:
        all_roots: List of real roots.
    """

    # Step 1: Convert the cubic equation into a depressed cubic
    p = (3*a*c - b*b)/(3*a*a)  # Depressed cubic coefficient p
    q = (2*np.power(b,3) - 9*a*b*c + 27*(a*a)*d)/(27*np.power(a, 3))  # Depressed cubic coefficient q
    r_t_offset = b/(3*a)  # Shift term to simplify roots

    all_roots = []  # List to store the roots

    # Calculate the discriminant of the depressed cubic
    discriminant = -((4*np.power(p,3))+27*q*q)

    # Case 1: Discriminant < 0, use Cardano's method (one real root)
    if discriminant < 0:
        sqrt_part = np.sqrt(((q*q)/4)+(np.power(p,3))/27)  # Square root part for Cardano's method
        u1 = -(q/2) + sqrt_part  # First value for cubic root calculation
        u2 = -(q/2) - sqrt_part  # Second value for cubic root calculation
        t1 = np.cbrt(u1) + np.cbrt(u2)  # Combine cube roots to find the real root
        r1 = t1 - b/(3*a)  # Adjust for the shifted term
        print("The cubic has only one real solution:")
        all_roots = [r1]

    # Case 2: Discriminant is close to 0, multiple real roots (either triple root or two real roots)
    elif np.isclose(discriminant, 0):
        if p == 0:
            # Special case: triple root at 0
            r1 = 0
            r2 = 0
            r3 = 0
            all_roots = [0, 0, 0]  # Triple root at zero
        else:
            # General case: three real roots (but one is repeated)
            t1 = (3*q)/p  # First root
            t2 = -0.5*t1  # Second root
            t3 = t2  # Third root (same as second root)
            r1 = t1 - r_t_offset  # Adjust for the shifted term
            r2 = t2 - r_t_offset  # Adjust for the shifted term
            r3 = t3 - r_t_offset  # Adjust for the shifted term
            all_roots = [r1, r2, r3]

    # Case 3: Discriminant > 0, three distinct real roots (use trigonometric method)
    elif discriminant > 0:
        scalar_part = 2*(np.sqrt(-p/3))  # Scaling factor for roots
        arccos_part = (1/3)*np.arccos(((3*q)/(2*p))*np.sqrt(-3/p))  # Angle part for trigonometric calculation
        t1 = scalar_part*np.cos(arccos_part)  # First root using cosine
        t2 = scalar_part*np.cos(arccos_part - 2*np.pi*1/3)  # Second root (shifted by 2π/3)
        t3 = scalar_part*np.cos(arccos_part - 2*np.pi*2/3)  # Third root (shifted by 4π/3)
        r1 = t1 - r_t_offset  # Adjust for the shifted term
        r2 = t2 - r_t_offset  # Adjust for the shifted term
        r3 = t3 - r_t_offset  # Adjust for the shifted term
        all_roots = [r1, r2, r3]

    # Sort the roots in ascending order
    all_roots.sort()

    # Return the list of roots
    return all_roots


# Example usage: solve the cubic equation x^3 - 1 = 0
print(solve_cubic(1, 0, 0, -1))  # This equation has roots at x = 1, -0.5 + 0.866j, -0.5 - 0.866j
